<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SIMRI3D: gdcmJpeg.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>gdcmJpeg.c</h1><a href="gdcmJpeg_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*************************************************************************</span>
00002 <span class="comment">* $Id: gdcmJpeg.c,v 1.1 2005/09/09 08:22:24 bellet Exp $</span>
00003 <span class="comment">**************************************************************************</span>
00004 <span class="comment"> This software is governed by the CeCILL  license under French law and</span>
00005 <span class="comment">  abiding by the rules of distribution of free software.  You can  use, </span>
00006 <span class="comment">  modify and/ or redistribute the software under the terms of the CeCILL</span>
00007 <span class="comment">  license as circulated by CEA, CNRS and INRIA at the following URL</span>
00008 <span class="comment">  "http://www.cecill.info". </span>
00009 <span class="comment">  </span>
00010 <span class="comment">  As a counterpart to the access to the source code and  rights to copy,</span>
00011 <span class="comment">  modify and redistribute granted by the license, users are provided only</span>
00012 <span class="comment">  with a limited warranty  and the software's author,  the holder of the</span>
00013 <span class="comment">  economic rights,  and the successive licensors  have only  limited</span>
00014 <span class="comment">  liability. </span>
00015 <span class="comment">  </span>
00016 <span class="comment">  In this respect, the user's attention is drawn to the risks associated</span>
00017 <span class="comment">  with loading,  using,  modifying and/or developing or reproducing the</span>
00018 <span class="comment">  software by the user in light of its specific status of free software,</span>
00019 <span class="comment">  that may mean  that it is complicated to manipulate,  and  that  also</span>
00020 <span class="comment">  therefore means  that it is reserved for developers  and  experienced</span>
00021 <span class="comment">  professionals having in-depth computer knowledge. Users are therefore</span>
00022 <span class="comment">  encouraged to load and test the software's suitability as regards their</span>
00023 <span class="comment">  requirements in conditions enabling the security of their systems and/or </span>
00024 <span class="comment">  data to be ensured and,  more generally, to use and operate it in the </span>
00025 <span class="comment">  same conditions as regards security. </span>
00026 <span class="comment">  </span>
00027 <span class="comment">  The fact that you are presently reading this means that you have had</span>
00028 <span class="comment">  knowledge of the CeCILL license and that you accept its terms.</span>
00029 <span class="comment">  </span>
00030 <span class="comment">  Copyright (c) CREATIS (Centre de Recherche et d'Applications en Traitement de</span>
00031 <span class="comment">  l'Image). All rights reserved. See License.txt for details.</span>
00032 <span class="comment">  </span>
00033 <span class="comment">  Version 1.0  05/09/2005</span>
00034 <span class="comment">*************************************************************************/</span>
00035 
00036 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00037 <span class="preprocessor">#include &lt;string.h&gt;</span>
00038 
00039 <span class="comment">/*</span>
00040 <span class="comment"> * Include file for users of JPEG library.</span>
00041 <span class="comment"> * You will need to have included system headers that define at least</span>
00042 <span class="comment"> * the typedefs FILE and size_t before you can include jpeglib.h.</span>
00043 <span class="comment"> * (stdio.h is sufficient on ANSI-conforming systems.)</span>
00044 <span class="comment"> * You may also wish to include "jerror.h".</span>
00045 <span class="comment"> */</span>
00046 
00047 <span class="preprocessor">#include "<a class="code" href="jpeglib_8h.html">jpeglib.h</a>"</span>
00048 
00049 <span class="comment">/*</span>
00050 <span class="comment"> * &lt;setjmp.h&gt; is used for the optional error recovery mechanism shown in</span>
00051 <span class="comment"> * the second part of the example.</span>
00052 <span class="comment"> */</span>
00053 
00054 <span class="preprocessor">#include &lt;setjmp.h&gt;</span>
00055 
00056 
00057 <span class="comment">/******************** JPEG DECOMPRESSION SAMPLE INTERFACE *******************/</span>
00058 
00059 <span class="comment">/* This half of the example shows how to read data from the JPEG decompressor.</span>
00060 <span class="comment"> * It's a bit more refined than the above, in that we show:</span>
00061 <span class="comment"> *   (a) how to modify the JPEG library's standard error-reporting behavior;</span>
00062 <span class="comment"> *   (b) how to allocate workspace using the library's memory manager.</span>
00063 <span class="comment"> *</span>
00064 <span class="comment"> * Just to make this example a little different from the first one, we'll</span>
00065 <span class="comment"> * assume that we do not intend to put the whole image into an in-memory</span>
00066 <span class="comment"> * buffer, but to send it line-by-line someplace else.  We need a one-</span>
00067 <span class="comment"> * scanline-high JSAMPLE array as a work buffer, and we will let the JPEG</span>
00068 <span class="comment"> * memory manager allocate it for us.  This approach is actually quite useful</span>
00069 <span class="comment"> * because we don't need to remember to deallocate the buffer separately: it</span>
00070 <span class="comment"> * will go away automatically when the JPEG object is cleaned up.</span>
00071 <span class="comment"> */</span>
00072 
00073 
00074 <span class="comment">/*</span>
00075 <span class="comment"> * ERROR HANDLING:</span>
00076 <span class="comment"> *</span>
00077 <span class="comment"> * The JPEG library's standard error handler (jerror.c) is divided into</span>
00078 <span class="comment"> * several "methods" which you can override individually.  This lets you</span>
00079 <span class="comment"> * adjust the behavior without duplicating a lot of code, which you might</span>
00080 <span class="comment"> * have to update with each future release.</span>
00081 <span class="comment"> *</span>
00082 <span class="comment"> * Our example here shows how to override the "error_exit" method so that</span>
00083 <span class="comment"> * control is returned to the library's caller when a fatal error occurs,</span>
00084 <span class="comment"> * rather than calling exit() as the standard error_exit method does.</span>
00085 <span class="comment"> *</span>
00086 <span class="comment"> * We use C's setjmp/longjmp facility to return control.  This means that the</span>
00087 <span class="comment"> * routine which calls the JPEG library must first execute a setjmp() call to</span>
00088 <span class="comment"> * establish the return point.  We want the replacement error_exit to do a</span>
00089 <span class="comment"> * longjmp().  But we need to make the setjmp buffer accessible to the</span>
00090 <span class="comment"> * error_exit routine.  To do this, we make a private extension of the</span>
00091 <span class="comment"> * standard JPEG error handler object.  (If we were using C++, we'd say we</span>
00092 <span class="comment"> * were making a subclass of the regular error handler.)</span>
00093 <span class="comment"> *</span>
00094 <span class="comment"> * Here's the extended error handler struct:</span>
00095 <span class="comment"> */</span>
00096 
<a name="l00097"></a><a class="code" href="structmy__error__mgr.html">00097</a> <span class="keyword">struct </span><a class="code" href="structmy__error__mgr.html">my_error_mgr</a> {
<a name="l00098"></a><a class="code" href="structmy__error__mgr.html#o0">00098</a>   <span class="keyword">struct </span><a class="code" href="structjpeg__error__mgr.html">jpeg_error_mgr</a> pub;  <span class="comment">/* "public" fields */</span>
<a name="l00099"></a><a class="code" href="structmy__error__mgr.html#o1">00099</a>   jmp_buf <a class="code" href="structmy__error__mgr.html#o1">setjmp_buffer</a>;   <span class="comment">/* for return to caller */</span>
00100 };
00101 
<a name="l00102"></a><a class="code" href="gdcmJpeg_8c.html#a0">00102</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structmy__error__mgr.html">my_error_mgr</a> * <a class="code" href="structmy__error__mgr.html">my_error_ptr</a>;
00103 
00104 <span class="comment">/*</span>
00105 <span class="comment"> * Here's the routine that will replace the standard error_exit method:</span>
00106 <span class="comment"> */</span>
00107 
00108 <a class="code" href="jmorecfg_8h.html#a7">METHODDEF</a>(<span class="keywordtype">void</span>)
<a name="l00109"></a><a class="code" href="gdcmJpeg_8c.html#a1">00109</a> my_error_exit (<a class="code" href="structjpeg__common__struct.html">j_common_ptr</a> cinfo)
00110 {
00111   <span class="comment">/* cinfo-&gt;err really points to a my_error_mgr struct, so coerce pointer */</span>
00112   <a class="code" href="structmy__error__mgr.html">my_error_ptr</a> myerr = (<a class="code" href="structmy__error__mgr.html">my_error_ptr</a>) cinfo-&gt;err;
00113 
00114   <span class="comment">/* Always display the message. */</span>
00115   <span class="comment">/* We could postpone this until after returning, if we chose. */</span>
00116   (*cinfo-&gt;err-&gt;output_message) (cinfo);
00117 
00118   <span class="comment">/* Return control to the setjmp point */</span>
00119   longjmp(myerr-&gt;<a class="code" href="structmy__error__mgr.html#o1">setjmp_buffer</a>, 1);
00120 }
00121 
00122 
00123 <span class="comment">/*</span>
00124 <span class="comment"> * Sample routine for JPEG decompression.  We assume that the source file name</span>
00125 <span class="comment"> * is passed in.  We want to return 1 on success, 0 on error.</span>
00126 <span class="comment"> */</span>
00127 
00128 <span class="comment">/*</span>
00129 <span class="comment">//GLOBAL(int)</span>
00130 <span class="comment">int</span>
00131 <span class="comment">gdcmFile::gdcm_read_JPEG_file (void * image_buffer) {</span>
00132 <span class="comment">*/</span>
00133 
<a name="l00134"></a><a class="code" href="iddcmjpeg_8h.html#a3">00134</a> <span class="keywordtype">int</span> <a class="code" href="iddcmjpeg_8h.html#a3">gdcm_read_JPEG_file</a> (<span class="keywordtype">void</span> * image_buffer, FILE * fp) {
00135 <span class="keywordtype">char</span> *pimage;
00136 
00137   <span class="comment">/* This struct contains the JPEG decompression parameters and pointers to</span>
00138 <span class="comment">   * working space (which is allocated as needed by the JPEG library).</span>
00139 <span class="comment">   */</span>
00140   <span class="keyword">struct </span><a class="code" href="structjpeg__decompress__struct.html">jpeg_decompress_struct</a> cinfo;
00141   <span class="comment">/* We use our private extension JPEG error handler.</span>
00142 <span class="comment">   * Note that this struct must live as long as the main JPEG parameter</span>
00143 <span class="comment">   * struct, to avoid dangling-pointer problems.</span>
00144 <span class="comment">   */</span>
00145   <span class="keyword">struct </span><a class="code" href="structmy__error__mgr.html">my_error_mgr</a> jerr;
00146   <span class="comment">/* More stuff */</span>
00147  
00148   <a class="code" href="jpeglib_8h.html#a33">JSAMPARRAY</a> buffer;    <span class="comment">/* Output row buffer */</span>
00149   
00150   <span class="comment">// rappel :</span>
00151   <span class="comment">// typedef unsigned char JSAMPLE;</span>
00152   <span class="comment">// typedef JSAMPLE FAR *JSAMPROW; /* ptr to one image row of pixel samples. */</span>
00153   <span class="comment">// typedef JSAMPROW *JSAMPARRAY;  /* ptr to some rows (a 2-D sample array) */</span>
00154   <span class="comment">// typedef JSAMPARRAY *JSAMPIMAGE;   /* a 3-D sample array: top index is color */</span>
00155   
00156   
00157   <span class="keywordtype">int</span> row_stride;    <span class="comment">/* physical row width in output buffer */</span>
00158 
00159   <span class="comment">/* In this example we want to open the input file before doing anything else,</span>
00160 <span class="comment">   * so that the setjmp() error recovery below can assume the file is open.</span>
00161 <span class="comment">   * VERY IMPORTANT: use "b" option to fopen() if you are on a machine that</span>
00162 <span class="comment">   * requires it in order to read binary files.</span>
00163 <span class="comment">   */</span>
00164 
00165 
00166 printf(<span class="stringliteral">"entree dans gdcmFile::gdcm_read_JPEG_file, depuis lidido-jpeg\n"</span>);
00167 
00168   <span class="comment">/* Step 1: allocate and initialize JPEG decompression object */</span>
00169   
00170 printf(<span class="stringliteral">"Entree Step 1\n"</span>);
00171 
00172   <span class="comment">/* We set up the normal JPEG error routines, then override error_exit. */</span>
00173   cinfo.err = jpeg_std_error(&amp;jerr.<a class="code" href="structmy__error__mgr.html#o0">pub</a>);
00174   jerr.<a class="code" href="structmy__error__mgr.html#o0">pub</a>.error_exit = <a class="code" href="gdcmJpeg_8c.html#a1">my_error_exit</a>;
00175   <span class="comment">/* Establish the setjmp return context for my_error_exit to use. */</span>
00176   <span class="keywordflow">if</span> (setjmp(jerr.<a class="code" href="structmy__error__mgr.html#o1">setjmp_buffer</a>)) {
00177     <span class="comment">/* If we get here, the JPEG code has signaled an error.</span>
00178 <span class="comment">     * We need to clean up the JPEG object, close the input file, and return.</span>
00179 <span class="comment">     */</span>
00180     jpeg_destroy_decompress(&amp;cinfo);
00181  
00182     <span class="keywordflow">return</span> 0;
00183   }
00184   <span class="comment">/* Now we can initialize the JPEG decompression object. */</span>
00185   <a class="code" href="jpeglib_8h.html#a20">jpeg_create_decompress</a>(&amp;cinfo);
00186 
00187   <span class="comment">/* Step 2: specify data source (eg, a file) */</span>
00188 printf(<span class="stringliteral">"Entree Step 2\n"</span>);
00189   jpeg_stdio_src(&amp;cinfo, fp);
00190 
00191   <span class="comment">/* Step 3: read file parameters with jpeg_read_header() */</span>
00192 
00193 printf(<span class="stringliteral">"Entree Step 3\n"</span>);
00194 
00195   (<span class="keywordtype">void</span>) jpeg_read_header(&amp;cinfo, <a class="code" href="idarg_8h.html#a4">TRUE</a>);
00196   <span class="comment">/* We can ignore the return value from jpeg_read_header since</span>
00197 <span class="comment">   *   (a) suspension is not possible with the stdio data source, and</span>
00198 <span class="comment">   *   (b) we passed TRUE to reject a tables-only JPEG file as an error.</span>
00199 <span class="comment">   * See libjpeg.doc for more info.</span>
00200 <span class="comment">   */</span>
00201 
00202   <span class="comment">/* Step 4: set parameters for decompression */</span>
00203 
00204 printf(<span class="stringliteral">"Entree Step 4\n"</span>);
00205 
00206   <span class="comment">/* In this example, we don't need to change any of the defaults set by</span>
00207 <span class="comment">   * jpeg_read_header(), so we do nothing here.</span>
00208 <span class="comment">   */</span>
00209 
00210   <span class="comment">/* Step 5: Start decompressor */</span>
00211   
00212 printf(<span class="stringliteral">"Entree Step 5\n"</span>);
00213 
00214   (<span class="keywordtype">void</span>) jpeg_start_decompress(&amp;cinfo);
00215   <span class="comment">/* We can ignore the return value since suspension is not possible</span>
00216 <span class="comment">   * with the stdio data source.</span>
00217 <span class="comment">   */</span>
00218 
00219   <span class="comment">/* We may need to do some setup of our own at this point before reading</span>
00220 <span class="comment">   * the data.  After jpeg_start_decompress() we have the correct scaled</span>
00221 <span class="comment">   * output image dimensions available, as well as the output colormap</span>
00222 <span class="comment">   * if we asked for color quantization.</span>
00223 <span class="comment">   * In this example, we need to make an output work buffer of the right size.</span>
00224 <span class="comment">   */</span> 
00225   <span class="comment">/* JSAMPLEs per row in output buffer */</span>
00226   row_stride = cinfo.<a class="code" href="structjpeg__decompress__struct.html#o22">output_width</a> * cinfo.<a class="code" href="structjpeg__decompress__struct.html#o25">output_components</a>;
00227   <span class="comment">/* Make a one-row-high sample array that will go away when done with image */</span>
00228   buffer = (*cinfo.mem-&gt;alloc_sarray)
00229       ((<a class="code" href="structjpeg__common__struct.html">j_common_ptr</a>) &amp;cinfo, <a class="code" href="jpeglib_8h.html#a16">JPOOL_IMAGE</a>, row_stride, 1);
00230 
00231   <span class="comment">/* Step 6: while (scan lines remain to be read) */</span>
00232   <span class="comment">/*           jpeg_read_scanlines(...); */</span>
00233 
00234   <span class="comment">/* Here we use the library's state variable cinfo.output_scanline as the</span>
00235 <span class="comment">   * loop counter, so that we don't have to keep track ourselves.</span>
00236 <span class="comment">   */</span>
00237  
00238  printf(<span class="stringliteral">"Entree Step 6\n"</span>); 
00239   
00240    printf (<span class="stringliteral">"cinfo.output_height %d  cinfo.output_width %d\n"</span>,cinfo.<a class="code" href="structjpeg__decompress__struct.html#o23">output_height</a>,cinfo.<a class="code" href="structjpeg__decompress__struct.html#o22">output_width</a>);
00241  
00242   pimage=(<span class="keywordtype">char</span> *)image_buffer;
00243   
00244   
00245   <span class="keywordflow">while</span> (cinfo.<a class="code" href="structjpeg__decompress__struct.html#o29">output_scanline</a> &lt; cinfo.<a class="code" href="structjpeg__decompress__struct.html#o23">output_height</a>) {
00246     <span class="comment">/* jpeg_read_scanlines expects an array of pointers to scanlines.</span>
00247 <span class="comment">     * Here the array is only one element long, but you could ask for</span>
00248 <span class="comment">     * more than one scanline at a time if that's more convenient.</span>
00249 <span class="comment">     */</span>
00250      
00251      <span class="comment">// l'image est deja allouée (et passée en param)</span>
00252      <span class="comment">// on ecrit directement les pixels</span>
00253      <span class="comment">// (on DEVRAIT pouvoir)</span>
00254     
00255     <span class="comment">//(void) jpeg_read_scanlines(&amp;cinfo, pimage, 1);</span>
00256     
00257      (<span class="keywordtype">void</span>) jpeg_read_scanlines(&amp;cinfo, buffer, 1); 
00258      memcpy( pimage, buffer[0],row_stride*2 ); <span class="comment">// FIXME : *2  car 16 bits?!?</span>
00259    <span class="comment">//printf("cinfo.output_scanline %d\n",cinfo.output_scanline );  </span>
00260      
00261     pimage+=row_stride*2; <span class="comment">// FIXME : *2 car 16 bits?!?  </span>
00262   }
00263  
00264   <span class="comment">/* Step 7: Finish decompression */</span>
00265 
00266 printf(<span class="stringliteral">"Entree Step 7\n"</span>);
00267 
00268   (<span class="keywordtype">void</span>) jpeg_finish_decompress(&amp;cinfo);
00269   <span class="comment">/* We can ignore the return value since suspension is not possible</span>
00270 <span class="comment">   * with the stdio data source.</span>
00271 <span class="comment">   */</span>
00272 
00273   <span class="comment">/* Step 8: Release JPEG decompression object */</span>
00274 
00275 printf(<span class="stringliteral">"Entree Step 8\n"</span>);
00276 
00277   <span class="comment">/* This is an important step since it will release a good deal of memory. */</span>
00278   jpeg_destroy_decompress(&amp;cinfo);
00279 
00280   <span class="comment">/* After finish_decompress, we can close the input file.</span>
00281 <span class="comment">   * Here we postpone it until after no more JPEG errors are possible,</span>
00282 <span class="comment">   * so as to simplify the setjmp error logic above.  (Actually, I don't</span>
00283 <span class="comment">   * think that jpeg_destroy can do an error exit, but why assume anything...)</span>
00284 <span class="comment">   */</span>
00285 
00286   <span class="comment">/* At this point you may want to check to see whether any corrupt-data</span>
00287 <span class="comment">   * warnings occurred (test whether jerr.pub.num_warnings is nonzero).</span>
00288 <span class="comment">   */</span>
00289 
00290   <span class="comment">/* And we're done! */</span>
00291   <span class="keywordflow">return</span> 1;
00292 }
00293 
00294 
00295 <span class="comment">/*</span>
00296 <span class="comment"> * SOME FINE POINTS:</span>
00297 <span class="comment"> *</span>
00298 <span class="comment"> * In the above code, we ignored the return value of jpeg_read_scanlines,</span>
00299 <span class="comment"> * which is the number of scanlines actually read.  We could get away with</span>
00300 <span class="comment"> * this because we asked for only one line at a time and we weren't using</span>
00301 <span class="comment"> * a suspending data source.  See libjpeg.doc for more info.</span>
00302 <span class="comment"> *</span>
00303 <span class="comment"> * We cheated a bit by calling alloc_sarray() after jpeg_start_decompress();</span>
00304 <span class="comment"> * we should have done it beforehand to ensure that the space would be</span>
00305 <span class="comment"> * counted against the JPEG max_memory setting.  In some systems the above</span>
00306 <span class="comment"> * code would risk an out-of-memory error.  However, in general we don't</span>
00307 <span class="comment"> * know the output image dimensions before jpeg_start_decompress(), unless we</span>
00308 <span class="comment"> * call jpeg_calc_output_dimensions().  See libjpeg.doc for more about this.</span>
00309 <span class="comment"> *</span>
00310 <span class="comment"> * Scanlines are returned in the same order as they appear in the JPEG file,</span>
00311 <span class="comment"> * which is standardly top-to-bottom.  If you must emit data bottom-to-top,</span>
00312 <span class="comment"> * you can use one of the virtual arrays provided by the JPEG memory manager</span>
00313 <span class="comment"> * to invert the data.  See wrbmp.c for an example.</span>
00314 <span class="comment"> *</span>
00315 <span class="comment"> * As with compression, some operating modes may require temporary files.</span>
00316 <span class="comment"> * On some systems you may need to set up a signal handler to ensure that</span>
00317 <span class="comment"> * temporary files are deleted if the program is interrupted.  See libjpeg.doc.</span>
00318 <span class="comment"> */</span>
00319 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 20 14:28:13 2006 for SIMRI3D by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
